import fontforge
import os
import sys

# Define the new combined font family name
NEW_FONT_FAMILY_NAME = "jakobsXenon"

def set_sfnt_names(font, family_name, sub_family_name, unique_id, full_name, postscript_name):
    """
    Sets the SFNT 'name' table entries for a font.
    This is crucial for how operating systems and applications identify the font.
    """
    # Clear existing names to avoid conflicts or old data
    font.sfnt_names = ()

    # Using "English (US)" as the language identifier for all entries
    lang = "English (US)"

    # Add essential SFNT name entries (Name ID reference):
    # 1: Font Family name
    # 2: Font Subfamily name (e.g., "Regular", "Bold", "Italic")
    # 3: Unique font identifier
    # 4: Full font name (e.g., "FamilyName Regular")
    # 6: PostScript name (e.g., "FamilyName-Regular")

    font.appendSFNTName(lang, "Family", family_name)
    font.appendSFNTName(lang, "SubFamily", sub_family_name)
    font.appendSFNTName(lang, "UniqueID", unique_id)
    font.appendSFNTName(lang, "Fullname", full_name)
    font.appendSFNTName(lang, "PostScriptName", postscript_name)
    font.appendSFNTName(lang, "Version", "Version 1.000")


def configure_and_open_font(filepath, new_sub_family_name, is_italic, is_bold, base_unique_id):
    """
    Opens a font, sets its internal names and styles, and returns the font object.
    """
    try:
        font = fontforge.open(filepath)
        print(f"Opened font: {filepath}")
    except Exception as e:
        print(f"Error opening font {filepath}: {e}")
        sys.exit(1)

    # Set basic font properties
    font.familyname = NEW_FONT_FAMILY_NAME
    font.fullname = f"{NEW_FONT_FAMILY_NAME} {new_sub_family_name}"
    # PostScript name should not have spaces and is usually FamilyName-SubFamily
    font.fontname = f"{NEW_FONT_FAMILY_NAME}-{new_sub_family_name.replace(' ', '')}"

    # Set SFNT 'name' table
    # Unique ID should be truly unique for each font within the collection
    unique_id_base = f"{NEW_FONT_FAMILY_NAME};{new_sub_family_name};{base_unique_id}"
    postscript_name = font.fontname

    set_sfnt_names(font, NEW_FONT_FAMILY_NAME, new_sub_family_name, unique_id_base, font.fullname, postscript_name)

    # Set MacStyle bits and italic angle
    font.italicangle = 0 # Reset to non-italic by default
    font.macstyle = 0    # Reset macstyle flags

    if is_italic:
        font.italicangle = 12 # Common italic angle, adjust as needed
        font.macstyle = font.macstyle | 2 # Set italic bit (bit 1)
    if is_bold:
        font.weight = "Bold" # Set PostScript weight string
        font.os2_weight = 700 # Bold weight class
        font.macstyle = font.macstyle | 1 # Set bold bit (bit 0)
    else:
        font.weight = "Regular" # Set PostScript weight string
        font.os2_weight = 400 # Regular weight class

    # Ensure other important font info is consistent
    font.version = "1.000"
    font.comment = f"Generated by FontForge - {NEW_FONT_FAMILY_NAME} {new_sub_family_name}"

    font.encoding = "UnicodeFull" # Ensure full Unicode coverage

    print(f"Configured font {os.path.basename(filepath)} as {font.fullname}")
    return font

def merge_otf_to_otc(input_font_configs, output_otc_path):
    """
    Merges multiple font files into a single OTC (OpenType Collection) file
    after configuring their internal metadata.

    Args:
        input_font_configs (list): A list of dictionaries, where each dict contains:
            - 'path': Full path to the input .otf font file.
            - 'sub_family': The desired new sub-family name (e.g., "Regular", "Bold", "Italic").
            - 'is_italic': Boolean, whether this style should be marked as italic.
            - 'is_bold': Boolean, whether this style should be marked as bold.
            - 'unique_id_suffix': A suffix for the unique ID to differentiate original fonts.
        output_otc_path (str): The full path for the output .otc font collection file.
    """
    if not input_font_configs:
        print("Error: No input font configurations provided.")
        sys.exit(1)

    configured_fonts = []
    try:
        for config in input_font_configs:
            font_obj = configure_and_open_font(
                config['path'],
                config['sub_family'],
                config['is_italic'],
                config['is_bold'],
                config['unique_id_suffix']
            )
            configured_fonts.append(font_obj)

        if not configured_fonts:
            print("Error: No fonts were successfully processed for merging.")
            sys.exit(1)

        # The first font in the list will be used as the base for generateTtc
        # It's important that all fonts have consistent naming by this point
        main_font = configured_fonts[0]
        other_fonts_for_ttc = tuple(configured_fonts[1:])

        print(f"Attempting to generate OTC: {output_otc_path}")
        # Use the 'cff' flag for OpenType Collection with CFF outlines (from OTF)
        main_font.generateTtc(output_otc_path, other_fonts_for_ttc, ttcflags=("cff",))
        print(f"Successfully created font collection: {output_otc_path}")

    except Exception as e:
        print(f"Error during font collection generation: {e}")
        sys.exit(1)
    finally:
        # Close all opened fonts to free up resources
        for f in configured_fonts:
            f.close()
        print("All font files closed.")

if __name__ == "__main__":
    fonts_dir = "/Users/jakob/dotties/fonts/input/"
    output_dir = "/Users/jakob/dotties/fonts/output/"

    # Ensure the output directory exists
    os.makedirs(output_dir, exist_ok=True)

    # Define the input fonts and their intended roles in the new font family
    # Assuming 'regular.otf' and 'bold.otf' are from FamilyA
    # Assuming 'italic.otf' and 'boldItalic.otf' are from FamilyB
    input_font_configurations = [
        {
            'path': os.path.join(fonts_dir, "regular.otf"),
            'sub_family': "Regular",
            'is_italic': False,
            'is_bold': False,
            'unique_id_suffix': "FamilyA_Reg"
        },
        {
            'path': os.path.join(fonts_dir, "bold.otf"),
            'sub_family': "Bold",
            'is_italic': False,
            'is_bold': True,
            'unique_id_suffix': "FamilyA_Bold"
        },
        {
            'path': os.path.join(fonts_dir, "italic.otf"), # This will become Italic
            'sub_family': "Italic",
            'is_italic': True,
            'is_bold': False,
            'unique_id_suffix': "FamilyB_Reg" # Original FamilyB-Regular
        },
        {
            'path': os.path.join(fonts_dir, "boldItalic.otf"), # This will become Bold Italic
            'sub_family': "Bold Italic",
            'is_italic': True,
            'is_bold': True,
            'unique_id_suffix': "FamilyB_Bold" # Original FamilyB-Bold
        },
     ]

    output_collection_name = f"{NEW_FONT_FAMILY_NAME}.otc"
    output_collection_path = os.path.join(output_dir, output_collection_name)

    merge_otf_to_otc(input_font_configurations, output_collection_path)
